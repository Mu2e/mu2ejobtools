#!/usr/bin/perl -w
#
# A.Gaponenko, 2023
#

use Getopt::Long;
use File::Basename;
use Cwd 'abs_path';
use Fcntl qw(:DEFAULT);
use JSON;
use Archive::Tar;
use Digest;
use English qw( -no_match_vars ) ; # Avoids regex performance penalty
use strict;
use warnings;
no warnings 'portable'; # otherwise complaints about exceeding 32-bit integers

use Mu2eFilename;
use Mu2eDSName;

use lib dirname($0) . '/../perllib/';
use mu2ejobtools qw(:DEFAULT doubleQuote
                    filename_json filename_fcl
                    );

use Mu2eInSpecs;

use Data::Dumper; # for debugging


my $sp = Mu2eInSpecs->new;
$sp->disable_protocol(proto_ifdh);

#================================================================
sub my_random {
    my $h = Digest->new("SHA-256");
    foreach my $i (@_) {
        $h->add($i);
    }

    # the result should be the same on all systems
    # as long as the use of hexdigest is portable.
    my $rnd = hex substr($h->hexdigest, 0, 8);  #FIXME: increase this from 32 bits?  we may have 10^6 files...
    return $rnd;
}

#================================================================
# returns a list of basenames
sub primary_inputs($$) {
    my ($index, $in) = @_;
    my ($k, $v) = %$in;
    my $merge = $v->[0];
    my $filelist = $v->[1];

    # skip the first $index * $merge files,
    # then take what is left, up to $merge
    my $nf = scalar(@$filelist);
    my $first = $index*$merge;
    my $last = $first + $merge - 1;
    $last = $nf - 1 if $nf - 1 < $last;

    die "primary_inputs(): invalid index $index\n"
        unless $first <= $last; # no emtpy lists

    return @$filelist[$first .. $last];
}

#================================================================
# returns a list of basenames
sub aux_inputs($$) {
    my ($index, $ai) = @_;
    my $nreq = $ai->[0];
    my @infiles = @{$ai->[1]};

    # zero means take all files
    $nreq = scalar(@infiles) unless $nreq;

    # We want to draw nreq "random" files from the list, without
    # repetitions.
    my @res;
    for(my $count = 0; $count < $nreq; ++$count) {

        # The "random" part has to be reproducible. Instead of relying on
        # an external random number generator, make one from our inputs.
        my $rnd = my_random($index, @infiles);
        my $index = $rnd % scalar(@infiles);
        push @res, $infiles[$index];
        splice @infiles, $index, 1; # drop the file we just used from inputs
    }

    return @res;
}

#================================================================
sub format_filenames($$) {
    my ($sp, $list) = @_;

    my @res;

    foreach my $i (@$list) {
        my $apn = $sp->abspathname($i);
        my $dsn = Mu2eFilename->parse($i)->dataset->dsname;
        my $proto = $sp->protocol($dsn);
        if($proto eq proto_file) {
            push @res, $apn;
        }
        elsif($proto eq proto_root) {

            # the substitution is documented here
            # https://mu2ewiki.fnal.gov/wiki/DataTransfer#Load_balancer_door
            $apn =~ s|^/pnfs/|xroot://fndcadoor.fnal.gov//pnfs/fnal.gov/usr/|
                or die "Error: root protocol requested"
                ." but a file pathname does not start with /pnfs: $apn\n";

            push @res, $apn;
        }
        else {
            die "Error: unknown protocol $proto\n";
        }
    }

    return @res;
}

#================================================================
sub get_sequencer($$) {
    my ($index, $tbs) = @_;

    # See https://mu2ewiki.fnal.gov/wiki/FileNames#sequencer
    if(my $in = $tbs->{'inputs'}) {
        my @files = primary_inputs($index, $in);
        my @seqs = map { my $f = Mu2eFilename->parse($_); $f->sequencer } @files;
        # if input file names use a consistent formatting for the sequencer
        # then string sort will do what is needed
        @seqs = sort @seqs;
        return $seqs[0];
    }
    elsif(my $evid = $tbs->{'event_id'}) {
        my $run = $evid->{'source.firstRun'}
        or die "Error: get_sequencer(): can not get source.firstRun from event_id\n";
        my $subrun = $index;
        return sprintf('%06d_%08d', $run, $subrun);
   }

    die "Error: get_sequencer(): unsupported JSON content\n";
}

#================================================================
sub usage() {
    my $self = basename($0);

    my $inspec_opts = $sp->help_opts(' 'x11);
    chomp $inspec_opts;

    my $inspec_help = $sp->help_explanation(' 'x11);
    chomp $inspec_help;

    return <<EOF
Usage:
        $self \\
           --parfile=cnf.tar \\
           --index=<uint> \\
$inspec_opts
           [-h|--help]

This script prints out fcl config for a job with the given index in
the set of jobs defined by the parfile.  If the job needs any inputs,
their location and access protocol must be specified using the
following options:

$inspec_help
           --help or -h   prints out this message and stops processing.
EOF
}

#================================================================
my %opt;

GetOptions(\%opt,
           'parfile=s',
           'index=i',
           $sp->option_defs(),
           'help',
    )
    or die "\nError processing command line options.\n";

if($opt{'help'}) {
    print usage();
    exit 0;
}

#================================================================
# Check the fundamentals

die "Error: --parfile is required\n" unless $opt{'parfile'};
my $pfname = $opt{'parfile'};
die "Error: $pfname is not a file\n" unless -f $pfname;
die "Error: file $pfname is not readable\n" unless -r $pfname;

die "Error: --index is required\n" unless defined $opt{'index'};
my $index = $opt{'index'};
die "Error: --index must be non-negative, got: $index\n" if $index < 0;


my $jsstr = get_tar_member($pfname, filename_json);
die "Error: could not extract '". filename_json ."' from '$pfname'\n"
    unless defined $jsstr;

my $js = JSON->new->decode($jsstr);
my $tbs = $js->{'tbs'};
die "Error: could not extract tbs from the json\n"
    unless defined $tbs;

my @dslist = get_datasets($js);
$sp->initialize(\@dslist, \%opt);

#================================================================
# is the index in range?

if(my $njobs = get_njobs($js)) {
    die "Zero based index $index is too large for njobs = $njobs\n"
        unless $index < $njobs;
}

#================================================================
my $fb =
    "#----------------------------------------------------------------\n".
    "# Code added by mu2ejobfcl:\n";

#----------------------------------------------------------------
if($tbs->{'event_id'}) {
    my $evid = $tbs->{'event_id'};
    while(my($k, $v) = each %$evid) {
        $fb .= $k . ': ' . $v . ",\n";
    }
    $fb .= "source.firstSubRun: $index\n";
}

#----------------------------------------------------------------
if(my $in = $tbs->{'inputs'}) {
    my ($k, $v) = %$in;
    my @jobinputs = primary_inputs($index, $in);

    $fb .= "$k: [\n    "
        . join(",\n    ",
               doubleQuote(format_filenames($sp, \@jobinputs)))
        . "\n]\n";
}

#----------------------------------------------------------------
if(my $out = $tbs->{'outfiles'}) {
    my $seq = get_sequencer($index, $tbs);
    keys %$out; # reset the iterator, just in case
    while(my ($k, $v) = each(%$out)) {
        my $f = Mu2eFilename->parse($v);
        $f->sequencer($seq);
        $fb .= "$k: ".  doubleQuote($f->basename()) . "\n";
    }
}

#----------------------------------------------------------------
if(my $au = $tbs->{'auxin'}) {
    keys %$au; # reset the iterator
    while(my ($k, $v) = each(%$au)) {

        my @infiles = aux_inputs($index, $v);

        $fb .= "$k: [\n    "
            . join(",\n    ",
                   doubleQuote(format_filenames($sp, \@infiles)))
            . "\n]\n";
    }
}

#----------------------------------------------------------------
if($tbs->{'seed'}) {
    $fb .= $tbs->{'seed'} . ": " . (1+$index) . "\n";
}

#----------------------------------------------------------------
$fb .=
    "# End code added by mu2ejobfcl:\n".
    "#----------------------------------------------------------------\n";

#================================================================
my $orig_fcl = get_tar_member($pfname, filename_fcl);
die "Error: could not extract '". filename_fcl ."' from '$pfname'\n"
    unless defined $orig_fcl;

print $orig_fcl;
print $fb;

#================================================================
exit(0);
